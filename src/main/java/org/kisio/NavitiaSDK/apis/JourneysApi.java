/*
 * navitia
 *      navitia.io is the open API for building cool stuff with mobility data. It provides the following services      * journeys computation     * line schedules     * next departures     * exploration of public transport data / search places     * and sexy things such as isochrones      navitia is a HATEOAS API that returns JSON formated results     
 *
 * OpenAPI spec version: v2.38.0
 * Contact: navitia@googlegroups.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package org.kisio.NavitiaSDK.apis;

import org.kisio.NavitiaSDK.invokers.ApiCallback;
import org.kisio.NavitiaSDK.invokers.ApiClient;
import org.kisio.NavitiaSDK.invokers.ApiException;
import org.kisio.NavitiaSDK.invokers.ApiResponse;
import org.kisio.NavitiaSDK.invokers.Configuration;
import org.kisio.NavitiaSDK.invokers.Pair;
import org.kisio.NavitiaSDK.invokers.ProgressRequestBody;
import org.kisio.NavitiaSDK.invokers.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import org.kisio.NavitiaSDK.models.Journeys;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class JourneysApi {
    private ApiClient apiClient;

    public JourneysApi(String token) throws Exception {
        if (token == null || token.trim().isEmpty()) {
          throw new Exception("Navitia token cannot be empty");
        }
        ApiClient apiClient = new ApiClient();
        apiClient.setUsername(token);
        this.apiClient = apiClient;
    }

    /**
     * Build call for getCoverageLonLatJourneys
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getCoverageLonLatJourneysCall(BigDecimal lat, BigDecimal lon, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{lon};{lat}/journeys"
            .replaceAll("\\{" + "lat" + "\\}", apiClient.escapePathParam(lat.toString()))
            .replaceAll("\\{" + "lon" + "\\}", apiClient.escapePathParam(lon.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (forbiddenUris != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "count", count));
        if (isJourneySchedules != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_stands", bssStands));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            ""
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageLonLatJourneysValidateBeforeCall(BigDecimal lat, BigDecimal lon, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'lat' is set
        if (lat == null) {
            throw new ApiException("Missing the required parameter 'lat' when calling getCoverageLonLatJourneys(Async)");
        }
        
        // verify the required parameter 'lon' is set
        if (lon == null) {
            throw new ApiException("Missing the required parameter 'lon' when calling getCoverageLonLatJourneys(Async)");
        }
        

        com.squareup.okhttp.Call call = getCoverageLonLatJourneysCall(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected Journeys getCoverageLonLatJourneys(BigDecimal lat, BigDecimal lon, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        ApiResponse<Journeys> resp = getCoverageLonLatJourneysWithHttpInfo(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<Journeys> getCoverageLonLatJourneysWithHttpInfo(BigDecimal lat, BigDecimal lon, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageLonLatJourneysValidateBeforeCall(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageLonLatJourneysAsync(BigDecimal lat, BigDecimal lon, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatJourneysValidateBeforeCall(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageLonLatJourneysAsyncRaw(BigDecimal lat, BigDecimal lon, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatJourneysValidateBeforeCall(lat, lon, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public CoverageLonLatJourneysRequestBuilder newCoverageLonLatJourneysRequestBuilder() {
        return new CoverageLonLatJourneysRequestBuilder(this);
    }

    public class CoverageLonLatJourneysRequestBuilder {
        private JourneysApi currentApi;
        private BigDecimal lat;
        private BigDecimal lon;
        private String from;
        private String to;
        private String datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer count;
        private Boolean isJourneySchedules;
        private Integer minNbJourneys;
        private Integer maxNbJourneys;
        private Boolean bssStands;

        public CoverageLonLatJourneysRequestBuilder(JourneysApi currentApi) {
            this.currentApi = currentApi;
        }

        public CoverageLonLatJourneysRequestBuilder withLat(BigDecimal lat) {
            this.lat = lat;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withLon(BigDecimal lon) {
            this.lon = lon;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDatetime(String datetime) {
            this.datetime = datetime;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withCount(Integer count) {
            this.count = count;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withIsJourneySchedules(Boolean isJourneySchedules) {
            this.isJourneySchedules = isJourneySchedules;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMinNbJourneys(Integer minNbJourneys) {
            this.minNbJourneys = minNbJourneys;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withMaxNbJourneys(Integer maxNbJourneys) {
            this.maxNbJourneys = maxNbJourneys;
            return this;
        }
        public CoverageLonLatJourneysRequestBuilder withBssStands(Boolean bssStands) {
            this.bssStands = bssStands;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<Journeys > callback) throws ApiException {
            return currentApi.getCoverageLonLatJourneysAsync(this.lat, this.lon, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getCoverageLonLatJourneysAsyncRaw(this.lat, this.lon, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }
    }
    /**
     * Build call for getCoverageLonLatUriJourneys
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getCoverageLonLatUriJourneysCall(BigDecimal lat, BigDecimal lon, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{lon};{lat}/{uri}/journeys"
            .replaceAll("\\{" + "lat" + "\\}", apiClient.escapePathParam(lat.toString()))
            .replaceAll("\\{" + "lon" + "\\}", apiClient.escapePathParam(lon.toString()))
            .replaceAll("\\{" + "uri" + "\\}", apiClient.escapePathParam(uri.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (forbiddenUris != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "count", count));
        if (isJourneySchedules != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_stands", bssStands));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            ""
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageLonLatUriJourneysValidateBeforeCall(BigDecimal lat, BigDecimal lon, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'lat' is set
        if (lat == null) {
            throw new ApiException("Missing the required parameter 'lat' when calling getCoverageLonLatUriJourneys(Async)");
        }
        
        // verify the required parameter 'lon' is set
        if (lon == null) {
            throw new ApiException("Missing the required parameter 'lon' when calling getCoverageLonLatUriJourneys(Async)");
        }
        
        // verify the required parameter 'uri' is set
        if (uri == null) {
            throw new ApiException("Missing the required parameter 'uri' when calling getCoverageLonLatUriJourneys(Async)");
        }
        

        com.squareup.okhttp.Call call = getCoverageLonLatUriJourneysCall(lat, lon, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected Journeys getCoverageLonLatUriJourneys(BigDecimal lat, BigDecimal lon, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        ApiResponse<Journeys> resp = getCoverageLonLatUriJourneysWithHttpInfo(lat, lon, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<Journeys> getCoverageLonLatUriJourneysWithHttpInfo(BigDecimal lat, BigDecimal lon, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageLonLatUriJourneysValidateBeforeCall(lat, lon, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageLonLatUriJourneysAsync(BigDecimal lat, BigDecimal lon, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatUriJourneysValidateBeforeCall(lat, lon, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param lat  The latitude of where the coord you want to query (required)
     * @param lon  The longitude of where the coord you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageLonLatUriJourneysAsyncRaw(BigDecimal lat, BigDecimal lon, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageLonLatUriJourneysValidateBeforeCall(lat, lon, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public CoverageLonLatUriJourneysRequestBuilder newCoverageLonLatUriJourneysRequestBuilder() {
        return new CoverageLonLatUriJourneysRequestBuilder(this);
    }

    public class CoverageLonLatUriJourneysRequestBuilder {
        private JourneysApi currentApi;
        private BigDecimal lat;
        private BigDecimal lon;
        private String uri;
        private String from;
        private String to;
        private String datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer count;
        private Boolean isJourneySchedules;
        private Integer minNbJourneys;
        private Integer maxNbJourneys;
        private Boolean bssStands;

        public CoverageLonLatUriJourneysRequestBuilder(JourneysApi currentApi) {
            this.currentApi = currentApi;
        }

        public CoverageLonLatUriJourneysRequestBuilder withLat(BigDecimal lat) {
            this.lat = lat;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withLon(BigDecimal lon) {
            this.lon = lon;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withUri(String uri) {
            this.uri = uri;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withDatetime(String datetime) {
            this.datetime = datetime;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withCount(Integer count) {
            this.count = count;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withIsJourneySchedules(Boolean isJourneySchedules) {
            this.isJourneySchedules = isJourneySchedules;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMinNbJourneys(Integer minNbJourneys) {
            this.minNbJourneys = minNbJourneys;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withMaxNbJourneys(Integer maxNbJourneys) {
            this.maxNbJourneys = maxNbJourneys;
            return this;
        }
        public CoverageLonLatUriJourneysRequestBuilder withBssStands(Boolean bssStands) {
            this.bssStands = bssStands;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<Journeys > callback) throws ApiException {
            return currentApi.getCoverageLonLatUriJourneysAsync(this.lat, this.lon, this.uri, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getCoverageLonLatUriJourneysAsyncRaw(this.lat, this.lon, this.uri, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }
    }
    /**
     * Build call for getCoverageRegionJourneys
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getCoverageRegionJourneysCall(String region, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{region}/journeys"
            .replaceAll("\\{" + "region" + "\\}", apiClient.escapePathParam(region.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (forbiddenUris != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "count", count));
        if (isJourneySchedules != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_stands", bssStands));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            ""
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageRegionJourneysValidateBeforeCall(String region, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'region' is set
        if (region == null) {
            throw new ApiException("Missing the required parameter 'region' when calling getCoverageRegionJourneys(Async)");
        }
        

        com.squareup.okhttp.Call call = getCoverageRegionJourneysCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected Journeys getCoverageRegionJourneys(String region, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        ApiResponse<Journeys> resp = getCoverageRegionJourneysWithHttpInfo(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<Journeys> getCoverageRegionJourneysWithHttpInfo(String region, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageRegionJourneysValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageRegionJourneysAsync(String region, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionJourneysValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param region  The region you want to query (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageRegionJourneysAsyncRaw(String region, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionJourneysValidateBeforeCall(region, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public CoverageRegionJourneysRequestBuilder newCoverageRegionJourneysRequestBuilder() {
        return new CoverageRegionJourneysRequestBuilder(this);
    }

    public class CoverageRegionJourneysRequestBuilder {
        private JourneysApi currentApi;
        private String region;
        private String from;
        private String to;
        private String datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer count;
        private Boolean isJourneySchedules;
        private Integer minNbJourneys;
        private Integer maxNbJourneys;
        private Boolean bssStands;

        public CoverageRegionJourneysRequestBuilder(JourneysApi currentApi) {
            this.currentApi = currentApi;
        }

        public CoverageRegionJourneysRequestBuilder withRegion(String region) {
            this.region = region;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDatetime(String datetime) {
            this.datetime = datetime;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withCount(Integer count) {
            this.count = count;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withIsJourneySchedules(Boolean isJourneySchedules) {
            this.isJourneySchedules = isJourneySchedules;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMinNbJourneys(Integer minNbJourneys) {
            this.minNbJourneys = minNbJourneys;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withMaxNbJourneys(Integer maxNbJourneys) {
            this.maxNbJourneys = maxNbJourneys;
            return this;
        }
        public CoverageRegionJourneysRequestBuilder withBssStands(Boolean bssStands) {
            this.bssStands = bssStands;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<Journeys > callback) throws ApiException {
            return currentApi.getCoverageRegionJourneysAsync(this.region, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getCoverageRegionJourneysAsyncRaw(this.region, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }
    }
    /**
     * Build call for getCoverageRegionUriJourneys
     * @param region  The region you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getCoverageRegionUriJourneysCall(String region, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/coverage/{region}/{uri}/journeys"
            .replaceAll("\\{" + "region" + "\\}", apiClient.escapePathParam(region.toString()))
            .replaceAll("\\{" + "uri" + "\\}", apiClient.escapePathParam(uri.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (forbiddenUris != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "count", count));
        if (isJourneySchedules != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_stands", bssStands));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            ""
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getCoverageRegionUriJourneysValidateBeforeCall(String region, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'region' is set
        if (region == null) {
            throw new ApiException("Missing the required parameter 'region' when calling getCoverageRegionUriJourneys(Async)");
        }
        
        // verify the required parameter 'uri' is set
        if (uri == null) {
            throw new ApiException("Missing the required parameter 'uri' when calling getCoverageRegionUriJourneys(Async)");
        }
        

        com.squareup.okhttp.Call call = getCoverageRegionUriJourneysCall(region, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param region  The region you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected Journeys getCoverageRegionUriJourneys(String region, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        ApiResponse<Journeys> resp = getCoverageRegionUriJourneysWithHttpInfo(region, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param region  The region you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<Journeys> getCoverageRegionUriJourneysWithHttpInfo(String region, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        com.squareup.okhttp.Call call = getCoverageRegionUriJourneysValidateBeforeCall(region, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param region  The region you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageRegionUriJourneysAsync(String region, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionUriJourneysValidateBeforeCall(region, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param region  The region you want to query (required)
     * @param uri First part of the uri (required)
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getCoverageRegionUriJourneysAsyncRaw(String region, String uri, String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getCoverageRegionUriJourneysValidateBeforeCall(region, uri, from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public CoverageRegionUriJourneysRequestBuilder newCoverageRegionUriJourneysRequestBuilder() {
        return new CoverageRegionUriJourneysRequestBuilder(this);
    }

    public class CoverageRegionUriJourneysRequestBuilder {
        private JourneysApi currentApi;
        private String region;
        private String uri;
        private String from;
        private String to;
        private String datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer count;
        private Boolean isJourneySchedules;
        private Integer minNbJourneys;
        private Integer maxNbJourneys;
        private Boolean bssStands;

        public CoverageRegionUriJourneysRequestBuilder(JourneysApi currentApi) {
            this.currentApi = currentApi;
        }

        public CoverageRegionUriJourneysRequestBuilder withRegion(String region) {
            this.region = region;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withUri(String uri) {
            this.uri = uri;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withDatetime(String datetime) {
            this.datetime = datetime;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withCount(Integer count) {
            this.count = count;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withIsJourneySchedules(Boolean isJourneySchedules) {
            this.isJourneySchedules = isJourneySchedules;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMinNbJourneys(Integer minNbJourneys) {
            this.minNbJourneys = minNbJourneys;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withMaxNbJourneys(Integer maxNbJourneys) {
            this.maxNbJourneys = maxNbJourneys;
            return this;
        }
        public CoverageRegionUriJourneysRequestBuilder withBssStands(Boolean bssStands) {
            this.bssStands = bssStands;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<Journeys > callback) throws ApiException {
            return currentApi.getCoverageRegionUriJourneysAsync(this.region, this.uri, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getCoverageRegionUriJourneysAsyncRaw(this.region, this.uri, this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }
    }
    /**
     * Build call for getJourneys
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    private com.squareup.okhttp.Call getJourneysCall(String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/journeys";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (from != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "from", from));
        if (to != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "to", to));
        if (datetime != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime", datetime));
        if (datetimeRepresents != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "datetime_represents", datetimeRepresents));
        if (maxNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_transfers", maxNbTransfers));
        if (minNbTransfers != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_transfers", minNbTransfers));
        if (firstSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "first_section_mode[]", firstSectionMode));
        if (lastSectionMode != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "last_section_mode[]", lastSectionMode));
        if (maxDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration_to_pt", maxDurationToPt));
        if (maxWalkingDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_walking_duration_to_pt", maxWalkingDurationToPt));
        if (maxBikeDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bike_duration_to_pt", maxBikeDurationToPt));
        if (maxBssDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_bss_duration_to_pt", maxBssDurationToPt));
        if (maxCarDurationToPt != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_car_duration_to_pt", maxCarDurationToPt));
        if (walkingSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "walking_speed", walkingSpeed));
        if (bikeSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bike_speed", bikeSpeed));
        if (bssSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_speed", bssSpeed));
        if (carSpeed != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "car_speed", carSpeed));
        if (forbiddenUris != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "forbidden_uris[]", forbiddenUris));
        if (allowedId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("csv", "allowed_id[]", allowedId));
        if (disruptionActive != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "disruption_active", disruptionActive));
        if (dataFreshness != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "data_freshness", dataFreshness));
        if (maxDuration != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_duration", maxDuration));
        if (wheelchair != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "wheelchair", wheelchair));
        if (travelerType != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "traveler_type", travelerType));
        if (directPath != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "direct_path", directPath));
        if (count != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "count", count));
        if (isJourneySchedules != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "is_journey_schedules", isJourneySchedules));
        if (minNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "min_nb_journeys", minNbJourneys));
        if (maxNbJourneys != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max_nb_journeys", maxNbJourneys));
        if (bssStands != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bss_stands", bssStands));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            ""
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getJourneysValidateBeforeCall(String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = getJourneysCall(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * 
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return Journeys
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    protected Journeys getJourneys(String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        ApiResponse<Journeys> resp = getJourneysWithHttpInfo(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands);
        return resp.getData();
    }

    /**
     * 
     * 
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @return ApiResponse&lt;Journeys&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    private ApiResponse<Journeys> getJourneysWithHttpInfo(String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands) throws ApiException {
        com.squareup.okhttp.Call call = getJourneysValidateBeforeCall(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, null, null);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * 
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getJourneysAsync(String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<Journeys> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getJourneysValidateBeforeCall(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Journeys>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }

    /**
     *  (asynchronously)
     * 
     * @param from The id of the departure of your journey. If not provided an isochrone is computed. (optional)
     * @param to The id of the arrival of your journey. If not provided an isochrone is computed. (optional)
     * @param datetime Date and time to go/arrive (see &#x60;datetime_represents&#x60;). Note: the datetime must be in the coverage’s publication period. (optional)
     * @param datetimeRepresents Determine how datetime is handled.  Possible values:  * &#39;departure&#39; - Compute journeys starting after datetime  * &#39;arrival&#39; - Compute journeys arriving before datetime (optional, default to departure)
     * @param maxNbTransfers Maximum number of transfers in each journey (optional)
     * @param minNbTransfers Minimum number of transfers in each journey (optional)
     * @param firstSectionMode Force the first section mode if the first section is not a public transport one. &#x60;bss&#x60; stands for bike sharing system. Note 1: It’s an array, you can give multiple modes. Note 2: Choosing &#x60;bss&#x60; implicitly allows the walking mode since you might have to walk to the bss station. Note 3: The parameter is inclusive, not exclusive, so if you want to forbid a mode, you need to add all the other modes. Eg: If you never want to use a car, you need: &#x60;first_section_mode[]&#x3D;walking&amp;first_section_mode[]&#x3D;bss&amp;first_section_mode[]&#x3D;bike&amp;last_section_mode[]&#x3D;walking&amp;last_section_mode[]&#x3D;bss&amp;last_section_mode[]&#x3D;bike&#x60; (optional)
     * @param lastSectionMode Same as first_section_mode but for the last section. (optional)
     * @param maxDurationToPt Maximal duration of non public transport in second (optional)
     * @param maxWalkingDurationToPt Maximal duration of walking on public transport in second (optional)
     * @param maxBikeDurationToPt Maximal duration of bike on public transport in second (optional)
     * @param maxBssDurationToPt Maximal duration of bss on public transport in second (optional)
     * @param maxCarDurationToPt Maximal duration of car on public transport in second (optional)
     * @param walkingSpeed Walking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bikeSpeed Biking speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param bssSpeed Speed while using a bike from a bike sharing system for the fallback sections. Speed unit must be in meter/second (optional)
     * @param carSpeed Driving speed for the fallback sections. Speed unit must be in meter/second (optional)
     * @param forbiddenUris If you want to avoid lines, modes, networks, etc. Note: the forbidden_uris[] concern only the public transport objects. You can’t for example forbid the use of the bike with them, you have to set the fallback modes for this (first_section_mode[] and last_section_mode[]) (optional)
     * @param allowedId If you want to use only a small subset of the public transport objects in your solution. Note: The constraint intersects with forbidden_uris[]. For example, if you ask for &#x60;allowed_id[]&#x3D;line:A&amp;forbidden_uris[]&#x3D;physical_mode:Bus&#x60;, only vehicles of the line A that are not buses will be used. (optional)
     * @param disruptionActive DEPRECATED, replaced by &#x60;data_freshness&#x60;. If true the algorithm takes the disruptions into account, and thus avoid disrupted public transport. Nota: &#x60;disruption_active&#x3D;true&#x60; &lt;&#x3D;&gt; &#x60;data_freshness&#x3D;realtime&#x60; (optional)
     * @param dataFreshness Define the freshness of data to use to compute journeys. When using the following parameter &#x60;&amp;data_freshness&#x3D;base_schedule&#x60; you can get disrupted journeys in the response. You can then display the disruption message to the traveler and make a &#x60;realtime&#x60; request to get a new undisrupted solution.  Possible values:  * &#39;base_schedule&#39; - Use theoric schedule information  * &#39;adapted_schedule&#39; - Use of adapted schedule information (like strike adjusting, etc.). Prefer &#x60;realtime&#x60; for traveler information as it will also contain adapted information schedule.  * &#39;realtime&#39; - Use all realtime information (optional)
     * @param maxDuration Maximum duration of journeys in secondes. Really useful when computing an isochrone. (optional)
     * @param wheelchair If true the traveler is considered to be using a wheelchair, thus only accessible public transport are used. Be warned: many data are currently too faint to provide acceptable answers with this parameter on. (optional)
     * @param travelerType Define speeds and accessibility values for different kind of people. Each profile also automatically determines appropriate first and last section modes to the covered area. Note: this means that you might get car, bike, etc. fallback routes even if you set &#x60;forbidden_uris[]&#x60;! You can overload all parameters (especially speeds, distances, first and last modes) by setting all of them specifically. We advise that you don’t rely on the traveler_type’s fallback modes (&#x60;first_section_mode[]&#x60; and &#x60;last_section_mode[]&#x60;) and set them yourself. (optional)
     * @param directPath Specify if direct path should be suggested (optional, default to indifferent)
     * @param count Fixed number of different journeys (optional)
     * @param isJourneySchedules True when &#39;/journeys&#39; is called to computethe same journey schedules and it&#39;ll override some specific parameters (optional)
     * @param minNbJourneys Minimum number of different suggested journeys (optional)
     * @param maxNbJourneys Maximum number of different suggested journeys (optional)
     * @param bssStands Show bss stands availability in the bicycle_rental pois of response (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    protected com.squareup.okhttp.Call getJourneysAsyncRaw(String from, String to, String datetime, String datetimeRepresents, Integer maxNbTransfers, Integer minNbTransfers, List<String> firstSectionMode, List<String> lastSectionMode, Integer maxDurationToPt, Integer maxWalkingDurationToPt, Integer maxBikeDurationToPt, Integer maxBssDurationToPt, Integer maxCarDurationToPt, Float walkingSpeed, Float bikeSpeed, Float bssSpeed, Float carSpeed, List<String> forbiddenUris, List<String> allowedId, Boolean disruptionActive, String dataFreshness, Integer maxDuration, Boolean wheelchair, String travelerType, String directPath, Integer count, Boolean isJourneySchedules, Integer minNbJourneys, Integer maxNbJourneys, Boolean bssStands, final ApiCallback<String > callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getJourneysValidateBeforeCall(from, to, datetime, datetimeRepresents, maxNbTransfers, minNbTransfers, firstSectionMode, lastSectionMode, maxDurationToPt, maxWalkingDurationToPt, maxBikeDurationToPt, maxBssDurationToPt, maxCarDurationToPt, walkingSpeed, bikeSpeed, bssSpeed, carSpeed, forbiddenUris, allowedId, disruptionActive, dataFreshness, maxDuration, wheelchair, travelerType, directPath, count, isJourneySchedules, minNbJourneys, maxNbJourneys, bssStands, progressListener, progressRequestListener);
        apiClient.executeAsync(call, String.class, callback);
        return call;
    }

    public JourneysRequestBuilder newJourneysRequestBuilder() {
        return new JourneysRequestBuilder(this);
    }

    public class JourneysRequestBuilder {
        private JourneysApi currentApi;
        private String from;
        private String to;
        private String datetime;
        private String datetimeRepresents;
        private Integer maxNbTransfers;
        private Integer minNbTransfers;
        private List<String> firstSectionMode;
        private List<String> lastSectionMode;
        private Integer maxDurationToPt;
        private Integer maxWalkingDurationToPt;
        private Integer maxBikeDurationToPt;
        private Integer maxBssDurationToPt;
        private Integer maxCarDurationToPt;
        private Float walkingSpeed;
        private Float bikeSpeed;
        private Float bssSpeed;
        private Float carSpeed;
        private List<String> forbiddenUris;
        private List<String> allowedId;
        private Boolean disruptionActive;
        private String dataFreshness;
        private Integer maxDuration;
        private Boolean wheelchair;
        private String travelerType;
        private String directPath;
        private Integer count;
        private Boolean isJourneySchedules;
        private Integer minNbJourneys;
        private Integer maxNbJourneys;
        private Boolean bssStands;

        public JourneysRequestBuilder(JourneysApi currentApi) {
            this.currentApi = currentApi;
        }

        public JourneysRequestBuilder withFrom(String from) {
            this.from = from;
            return this;
        }
        public JourneysRequestBuilder withTo(String to) {
            this.to = to;
            return this;
        }
        public JourneysRequestBuilder withDatetime(String datetime) {
            this.datetime = datetime;
            return this;
        }
        public JourneysRequestBuilder withDatetimeRepresents(String datetimeRepresents) {
            this.datetimeRepresents = datetimeRepresents;
            return this;
        }
        public JourneysRequestBuilder withMaxNbTransfers(Integer maxNbTransfers) {
            this.maxNbTransfers = maxNbTransfers;
            return this;
        }
        public JourneysRequestBuilder withMinNbTransfers(Integer minNbTransfers) {
            this.minNbTransfers = minNbTransfers;
            return this;
        }
        public JourneysRequestBuilder withFirstSectionMode(List<String> firstSectionMode) {
            this.firstSectionMode = firstSectionMode;
            return this;
        }
        public JourneysRequestBuilder withLastSectionMode(List<String> lastSectionMode) {
            this.lastSectionMode = lastSectionMode;
            return this;
        }
        public JourneysRequestBuilder withMaxDurationToPt(Integer maxDurationToPt) {
            this.maxDurationToPt = maxDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxWalkingDurationToPt(Integer maxWalkingDurationToPt) {
            this.maxWalkingDurationToPt = maxWalkingDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxBikeDurationToPt(Integer maxBikeDurationToPt) {
            this.maxBikeDurationToPt = maxBikeDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxBssDurationToPt(Integer maxBssDurationToPt) {
            this.maxBssDurationToPt = maxBssDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withMaxCarDurationToPt(Integer maxCarDurationToPt) {
            this.maxCarDurationToPt = maxCarDurationToPt;
            return this;
        }
        public JourneysRequestBuilder withWalkingSpeed(Float walkingSpeed) {
            this.walkingSpeed = walkingSpeed;
            return this;
        }
        public JourneysRequestBuilder withBikeSpeed(Float bikeSpeed) {
            this.bikeSpeed = bikeSpeed;
            return this;
        }
        public JourneysRequestBuilder withBssSpeed(Float bssSpeed) {
            this.bssSpeed = bssSpeed;
            return this;
        }
        public JourneysRequestBuilder withCarSpeed(Float carSpeed) {
            this.carSpeed = carSpeed;
            return this;
        }
        public JourneysRequestBuilder withForbiddenUris(List<String> forbiddenUris) {
            this.forbiddenUris = forbiddenUris;
            return this;
        }
        public JourneysRequestBuilder withAllowedId(List<String> allowedId) {
            this.allowedId = allowedId;
            return this;
        }
        public JourneysRequestBuilder withDisruptionActive(Boolean disruptionActive) {
            this.disruptionActive = disruptionActive;
            return this;
        }
        public JourneysRequestBuilder withDataFreshness(String dataFreshness) {
            this.dataFreshness = dataFreshness;
            return this;
        }
        public JourneysRequestBuilder withMaxDuration(Integer maxDuration) {
            this.maxDuration = maxDuration;
            return this;
        }
        public JourneysRequestBuilder withWheelchair(Boolean wheelchair) {
            this.wheelchair = wheelchair;
            return this;
        }
        public JourneysRequestBuilder withTravelerType(String travelerType) {
            this.travelerType = travelerType;
            return this;
        }
        public JourneysRequestBuilder withDirectPath(String directPath) {
            this.directPath = directPath;
            return this;
        }
        public JourneysRequestBuilder withCount(Integer count) {
            this.count = count;
            return this;
        }
        public JourneysRequestBuilder withIsJourneySchedules(Boolean isJourneySchedules) {
            this.isJourneySchedules = isJourneySchedules;
            return this;
        }
        public JourneysRequestBuilder withMinNbJourneys(Integer minNbJourneys) {
            this.minNbJourneys = minNbJourneys;
            return this;
        }
        public JourneysRequestBuilder withMaxNbJourneys(Integer maxNbJourneys) {
            this.maxNbJourneys = maxNbJourneys;
            return this;
        }
        public JourneysRequestBuilder withBssStands(Boolean bssStands) {
            this.bssStands = bssStands;
            return this;
        }

        public com.squareup.okhttp.Call get(final ApiCallback<Journeys > callback) throws ApiException {
            return currentApi.getJourneysAsync(this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }

        public com.squareup.okhttp.Call rawGet(final ApiCallback<String > callback) throws ApiException {
            return currentApi.getJourneysAsyncRaw(this.from, this.to, this.datetime, this.datetimeRepresents, this.maxNbTransfers, this.minNbTransfers, this.firstSectionMode, this.lastSectionMode, this.maxDurationToPt, this.maxWalkingDurationToPt, this.maxBikeDurationToPt, this.maxBssDurationToPt, this.maxCarDurationToPt, this.walkingSpeed, this.bikeSpeed, this.bssSpeed, this.carSpeed, this.forbiddenUris, this.allowedId, this.disruptionActive, this.dataFreshness, this.maxDuration, this.wheelchair, this.travelerType, this.directPath, this.count, this.isJourneySchedules, this.minNbJourneys, this.maxNbJourneys, this.bssStands, callback);
        }
    }
}
